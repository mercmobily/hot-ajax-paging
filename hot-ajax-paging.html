<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../hot-deep-target-behavior/hot-deep-target-behavior.html">

<!--
`hot-ajax-paging`
Element to control an iron-ajax element

This element adds paging capabilities to iron-ajax. It also provides _all_ the information a pager element might possibly need to draw itself.
To use it, simply wrap an iron-ajax widget with it:

    <hot-ajax-paging per-page="10" current-page="{{currentPage}}" pager-data="{{pagerData}}">
      <iron-ajax auto url="/stores/polymer" handle-as="json" last-response="{{data}}"></iron-ajax>
    </hot-ajax-paging>

Interaction with the iron-ajax widget happens as follows:

* **Outgoing:** Whenever current-page changes, a `range` header is added to the `iron-ajax` widget, in the format `items=0-9` which will instruct the server only to return records 0 to 9.

* **Incoming:** Whenever the server responds with results, a header in the format `Content-Range items 0-24/66` is expected, where 66 is the total number of records. This information is used to effectively make the pager functional and properly sized. Before the first AJAX call returns, the pager won't even display (since it doesn't know how many pages it should show). Once the first AJAX call returns, the pager will display with the right information.

## pagerData

The (notifying) pagerData variable is updated every time anything about the pager changes. The `pagerData` variable will have the following fields:

* `items` - An array with the list of items. Each one is an object like this: `{page: 1, current: true}`. There will only be one item with its `current` property set to true
* `left` - The page linked by the item in the page on the far left
* `right` - The page linked by the item in the page on the far left
* `moreToLeft` - set to `true` if the most left item in the pager is not page 1
* `moreToRight` - set to `true` if the most right item in the pager is not the last page available
* `jumpNext` - the page number for the next "page"
* `jumpPrev` - the page number for the previous "page".
* `from` and `to` - the range of records shown. For example if there are 15 records and the current page is 1, `from` and `to` will be `0` and `1` respectively. For page 2, they will be `2` and `3`, and so on.
* `perPage` - How many records will are shown in each page
* `currentPage` - The current page
* `maxShownPages` - How many "boxes" the pager will display
* `totalPages` - The total number of pages
* `totalRecords` - The total number of records


## Setting properties

The pager needs to be set up.

* `maxShownPages` - The maximum number of pages the pager will ever show. Changing this value will implying firing up an AJAX request.
* `from` and `to` - The range of the records shown. Changing either one of them will fire up a new AJAX request. Also, changing `from` will possibly change `currentPage`
* `perPage` - How many records are shown in each page. Changing this value will _not_ fire up a new AJAX request. However, `currentPage` will likely change without firing up an AJAX request (since changing perPage will likely mean that you are looking at a different page, but the data is already loaded). Note that only `from` is taken into consideration. So, if you make perPage smaller, you will end up looking at a different page, showing too many records.
* `currentPage` - The current page. Changing this value will fire up a new AJAX request.

## Custom target

## Using a custom target ID

It's possible to specify the target ID directly and have the target input field further in the DOM, rather than being `<hot-ajax-paging>`'s first child:

    <hot-ajax-paging target-id="aj" per-page="10" current-page="{{currentPage}}" pager-data="{{pagerData}}">
      <div></div>
      <iron-ajax id="aj" auto url="/stores/polymer" handle-as="json" last-response="{{data}}"></iron-ajax>
    </hot-ajax-paging>

@demo demo/index.html
-->

<dom-module id="hot-ajax-paging">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>
  </template>

  <script>
    Polymer({

      is: 'hot-ajax-paging',

      properties: {

        /**
         * If specified, the widget will not target its first child in the light DOM, but
         * the element with id `targetId`
         */
        targetId: String,

        /**
         * The iron-ajax element being targeted (for setting request headers according to
         * the required range, and monitor results to determine the size of the pager
         */
        target: Object,

        /**
         * In terms of data range, the first record fetched in the range. 0 is the first one
         */
        from: {
          type: String,
          notify: true,
        },

        /**
         * In terms of data range, the last record fetched in the range.
         *
         */
        to: {
          type: String,
          notify: true,
        },

        /**
         * The number of records that will logicsally fit in a page
         */
        perPage: {
          type: String,
          notify: true
        },

        /**
         * The current page.
         */
        currentPage: {
          type: String,
          notify: true
        },

        /**
         * The size of the pager
         */
        maxShownPages: {
          type: String,
          value: 5
        },

        /**
         * The total number of pages returned by the iron-ajax request
         */
        totalPages: {
          type: Number,
          notify: true,
          readOnly: true
        },

        /**
         * The total number of records returned by the iron-ajax request
         *
         */
        totalRecords: {
          type: Number,
          notify: true,
          readOnly: true

        },

        /**
         * The pager data. This can be used by a pager widget (for example
         * hot-pager) to display a pager
         */
        pagerData: {
          type: Object,
          notify: true,
        },

        dpager: {
          type: String,
          notify: true
        },

      },

      observers: [
        '_rangeChanged(from,to)',
        '_currentPageChanged(currentPage)',
        '_perPageChanged(perPage)',
        '_calculatePagerData(currentPage,maxShownPages,totalPages)',
        '_calculateTotalPages(totalRecords,perPage)'
      ],

      _calculateTotalPages: function(totalRecords, perPage) {
        if (Number(this.perPage) == 0) return;

        // Calculate the number of pages
        this._setTotalPages(Math.floor(Number(totalRecords) / Number(this.perPage)));

        // Add an extra page for leftover results
        if (Number(totalRecords) % Number(this.perPage)) this._setTotalPages(this.totalPages + 1);
      },

      _changeTotalRecords: function(e) {
        if (e.detail != this.target.lastRequest) return;

        if (this.from === '' || this.to === '') return;

        // TODO: Make calculation of range pluggable?

        var range = e.detail.xhr.getResponseHeader('Content-Range');
        if (range && range != '') this._setTotalRecords(Number(range.split('/')[1]));

      },

      _calculatePagerData: function() {
        //console.log("CALCULATING PAGER DATA");

        var newItems = [];
        var el;
        var left, right;

        var currentPage = Number(this.currentPage);
        var totalPages = Number(this.totalPages);
        var maxShownPages = Number(this.maxShownPages);

        // Handy numbers, usefull later
        var half = Math.floor(maxShownPages / 2);

        // Results are less than pagerMaxSquare: there will be no
        // centering, but simply all of them shown.
        // Thanks to this check, the following cases are _guarantee_ to be either
        // "left is out of range" or "right is out of range", and never both
        if (totalPages <= maxShownPages) {

          left = 1;
          right = totalPages;

        } else {

          // Prentend that the world is perfect, and the result are neatly
          // surrounded
          left = currentPage - half;
          right = left + maxShownPages - 1;

          // If left is out of range, set it to 0 and re-adjust right
          if (left < 1) {
            left = 1;
            right = left + maxShownPages - 1;

            // If right is out of range, set it to totalPages and readjust left
          } else if (right > totalPages) {
            right = totalPages;
            left = totalPages - maxShownPages + 1;
          }
        }

        var d = [];
        // Make up the pager data, based on "left" and "right"
        for (var i = left; i <= right; i++) {
          el = {};
          if (i == this.currentPage) el.current = true;
          el.page = i;
          newItems.push(el);

          // This is to create dpager, which can be used to display a
          // text-only version of the pager for debugging purposes
          if (el.current) d.push("*" + el.page + "*")
          else d.push(el.page);
        }

        var moreToLeft = left != 1;
        var moreToRight = right < totalPages;

        jumpPrev = null;
        if (moreToLeft) {
          var jumpPrev = right - maxShownPages;
          jumpPrev = jumpPrev < 1 ? 1 : jumpPrev;
        }
        jumpNext = null;
        if (moreToRight) {
          var jumpNext = left + maxShownPages;
          jumpNext = jumpNext > totalPages ? totalPages : jumpNext;
        }

        this.pagerData = {
          items: newItems,

          moreToLeft: moreToLeft,
          moreToRight: moreToRight,
          jumpNext: jumpNext,
          jumpPrev: jumpPrev,
          left: left,
          right: right,
          from: this.from,
          to: this.to,
          perPage: this.perPage,
          currentPage: this.currentPage,
          maxShownPages: this.maxShownPages,
          totalPages: this.totalPages,
          totalRecords: this.totalRecords,
        };

        this.dpager = d.join(' - ');
        //console.dir(this.pagerData);
      },

      //totalPages
      //currentPage
      //maxShownPages

      _currentPageChanged: function() {
        if (Number(this.currentPage) == 0) return;
        if (Number(this.perPage) == 0) return;

        // Adjusts the range to the new values,
        // Unless _preserveRange is on, which means that even though the page is changing,
        // the range stays the same.
        // This happens for example when perPage is changed -- so you are on a different page
        // keeping the same range
        if (this._preserveRange) return;

        var newPage = Number(this.currentPage);
        if (newPage < 0) newPage = 0;

        // On/off switch of preserveRange will endure that AJAX calls only
        // happen once (otherwise, it will happen twice, once for `from` and ince for `to`)
        this._preserveRange = true;
        this.from = (newPage - 1) * this.perPage;
        this._preserveRange = false;
        this.to = Number(this.from) + Number(this.perPage) - 1;
      },

      _perPageChanged: function(perpage) {
        if (Number(this.perPage) == 0) return;

        // The page changes, but the range won't.
        this._preserveRange = true;
        this.currentPage = Math.floor(Number(this.from) / Number(this.perPage)) + 1;
        this._preserveRange = false;
      },

      // This is the only hook that will actually trigger,
      // whenever appropriate, an AJAX call
      _rangeChanged: function(from, to) {

        //console.log("IN _rangeChanged!", from, to);

        // Range is being preserved. One of the inner
        // methods is changing the range but doesn't (yet?) want to
        // trigger any page recalculation nor AJAX
        if (this._preserveRange) return;

        // If there is no target, it means that the child is not yet ready()ed.
        // Set the _delayedRangeChanged flag, which will be picked up by `attached()`
        // which in turn will run `_rangeChanged()` manually
        if (!this.target) {
          this._delayedRangeChanged = true;
          return;
        }

        // Both ranges need to be valid values
        if (from === '' || to === '') return;
        //console.log("IN _rangeChanged ENTERED!", from, to);

        // Recalculate the page number. Note that it will need to
        // set _preserveRange, or changing page will then affect this very
        // piece of code...
        if (Number(this.perPage) != 0) {
          this._preserveRange = true;
          this.currentPage = Math.floor(Number(this.from) / Number(this.perPage)) + 1;
          this._preserveRange = false;
        }

        // TODO: Make range calculation pluggable?

        // Reset the "range" header, which will set the range of the call
        // and re-run the request
        delete this.target.headers.range;
        this.target.headers.range = "items=" + this.from + '-' + this.to;
        //console.log("AJAX CALL!!!")
        this.target.generateRequest();
      },

      attached: function() {

        this.async(function() {

          if (this.targetId) {
            this.target = this.queryEffectiveChildrenDeep("#" + this.targetId, true, 'hot-ajax-paging');
          } else {
            this.target = this.getEffectiveChildren()[0];
          }

          if (!this.target) throw (new Error("Child element not found"));

          this.listen(this.target, "response", "_changeTotalRecords");

          if (this._delayedRangeChanged) {
            //console.log("Running delayed _rateChanged")
            this._rangeChanged(this.from, this.to);
            // It will only happen once
            this._delayedRangeChanged = false;
          }

        });
      },

      detached: function() {
        this.unlisten(this.target, "response", "_changeTotalRecords");
      },

      _catcher: function(e) {},

    });
  </script>
</dom-module>
